CREATE TABLE dbBucket (
    id INTEGER PRIMARY KEY NOT NULL,
    data BLOB,
    version INTEGER NOT NULL,
    sortKey INTEGER DEFAULT NULL,
    upstreamId TEXT DEFAULT NULL,
    flags INTEGER NOT NULL DEFAULT 0
);

insert:
   REPLACE INTO dbBucket (id, version, data, sortKey, upstreamId, flags)
   SELECT
    :id,
    (SELECT COALESCE(MAX(version) + 1, 1) FROM dbBucket),
    :data,
    :sortKey,
    :upstreamId,
    :flags
   WHERE NOT EXISTS
    (SELECT 1 FROM dbBucket WHERE id = :id AND data = :data AND sortKey = :sortKey AND upstreamId = :upstreamId);

updateFlagsSilently:
    UPDATE dbBucket SET flags = :flags WHERE id = :id;

clearBucket:
   REPLACE INTO dbBucket (id, version, data)
   VALUES (:id, (SELECT COALESCE(MAX(version) + 1, 1) FROM dbBucket), NULL);

clearBuckets:
   UPDATE dbBucket
    SET data = NULL, version = :newVersion
    WHERE id >= :minInclusive AND id <= :maxInclusive;

getBucket:
    SELECT * FROM dbBucket WHERE id = :id;

resetAllVersions:
    UPDATE dbBucket SET version = 1;

getUpdatedBuckets:
   SELECT * FROM dbBucket WHERE version > :oldVersion AND data IS NOT NULL AND id IN :allowedBuckets;

getActiveBuckets:
   SELECT id, flags FROM dbBucket WHERE data IS NOT NULL ORDER BY sortKey ASC, id ASC LIMIT :limit;

getPotentialActiveBuckets:
   SELECT id FROM dbBucket ORDER BY sortKey ASC, id ASC LIMIT :limit;

getLatestVersion:
   SELECT MAX(version) FROM dbBucket;

getMaxSequenceId:
    SELECT MAX(id) FROM dbBucket;

getBucketWithUpstreamId:
    SELECT id FROM dbBucket WHERE upstreamId = :id LIMIT 1;

getOldestBucketInRange:
    SELECT id FROM dbBucket WHERE id >= :minInclusive AND id <= :maxInclusive ORDER BY data IS NOT NULL, sortKey IS NOT NULL, sortKey DESC, id ASC LIMIT 1;

deleteAll:
    DELETE FROM dbBucket;

insertRaw:
   REPLACE INTO dbBucket (id, version, data) VALUES ?;
